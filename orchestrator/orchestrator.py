from clan.factories.abstract_factory import AgentFactory
from clan.tools.agent_info_tool import load_agent_info
from clan.tools.command_executor import execute_command
import importlib
import os
import time
import json

# Helper to dynamically import agent classes
AGENT_CLASS_MAP = {
    "DeveloperAgent": "clan.agents.developer.DeveloperAgent",
    "UnitTesterAgent": "clan.agents.unit_tester.UnitTesterAgent",
    "CodeReviewerAgent": "clan.agents.code_reviewer.CodeReviewerAgent",
    "SummaryAgent": "clan.agents.core.summary_agent.SummaryAgent",
    "TaskPlannerAgent": "clan.agents.core.task_planner.TaskPlannerAgent",
    "FileAgent": "clan.agents.core.file_agent.FileAgent",
    "UserInteractionAgent": "clan.agents.core.user_interaction_agent.UserInteractionAgent",
    "CommandRunnerAgent": "clan.agents.command_runner_agent.CommandRunnerAgent",
    "GrepSearchAgent": "clan.agents.grep_search_agent.GrepSearchAgent",
    "GitAgent": "clan.agents.git_agent.GitAgent",
}

def get_agent_class(agent_name):
    path = AGENT_CLASS_MAP.get(agent_name)
    if not path:
        return None
    module_path, class_name = path.rsplit('.', 1)
    module = importlib.import_module(module_path)
    return getattr(module, class_name)

class Orchestrator:
    def __init__(self, factory: AgentFactory, file_agent=None, task_planner=None):
        self.agent_info = load_agent_info()
        self.agent_registry = self._init_agent_registry(factory, file_agent, task_planner)
        self.project_summary = ""
        self.file_agent = self.agent_registry.get("FileAgent")
        self.task_planner = self.agent_registry.get("TaskPlannerAgent")
        self.summary_agent = self.agent_registry.get("SummaryAgent")
        self.developer_agent = self.agent_registry.get("DeveloperAgent")

    def _init_agent_registry(self, factory, file_agent, task_planner):
        registry = {}
        # Core agents from factory
        registry["FileAgent"] = file_agent or factory.create_file_agent()
        registry["TaskPlannerAgent"] = task_planner or factory.create_task_planner()
        registry["SummaryAgent"] = factory.create_summary_agent()
        registry["DeveloperAgent"] = factory.create_developer_agent()
        registry["UserInteractionAgent"] = factory.create_user_interaction_agent()
        # Dynamically instantiate other agents
        for agent in self.agent_info:
            name = agent["name"]
            if name not in registry:
                agent_class = get_agent_class(name)
                if agent_class:
                    registry[name] = agent_class()
        return registry

    def run_workflow(self, task: str):
        print(f"[Orchestrator] Starting workflow for task: {task}")
        print("[Orchestrator] Designing project structure...")
        file_list = self.file_agent.act(task)
        print(f"[Orchestrator] Project structure:\n{self.file_agent.project_state.get_project_view()}")
        if not file_list:
            print("[Orchestrator] No files suggested by FileAgent.")
            return
        while True:
            print("[Orchestrator] Planning step-by-step agentic plan...")
            plan = self.task_planner.act(task, self.file_agent.project_state, context={"agents": self.agent_info})
            if not plan:
                print("[Orchestrator] No plan generated by TaskPlannerAgent.")
                return
            print("\n===== PROPOSED PLAN =====")
            print(json.dumps(plan, indent=2))
            print("=========================")
            user_input = input("Do you approve this plan? (yes/no/suggest): ").strip().lower()
            if user_input in ("yes", "y", "approve"):  # proceed
                break
            elif user_input in ("no", "n", "reject"):
                task = input("Please enter a new requirement or revision: ").strip()
            elif user_input.startswith("suggest") or user_input == "s":
                suggestion = input("Please enter your suggestion for the plan or a new requirement: ").strip()
                task = suggestion
            else:
                print("Unrecognized input. Please type 'yes', 'no', or 'suggest'.")
        # Build step lookup and dependency graph
        step_lookup = {step["step"]: step for step in plan}
        step_outputs = {}  # step_number -> output
        completed_steps = set()
        steps_to_run = set(step["step"] for step in plan)
        while steps_to_run:
            progress = False
            for step_num in list(steps_to_run):
                step = step_lookup[step_num]
                depends_on = step.get("depends_on", [])
                if all(dep in completed_steps for dep in depends_on):
                    agent_name = step.get("agent")
                    action = step.get("action")
                    targets = step.get("targets", [])
                    description = step.get("description", "")
                    expected_output = step.get("expected_output", "")
                    dependency_outputs = {dep: step_outputs[dep] for dep in depends_on if dep in step_outputs}
                    context = {
                        "dependency_outputs": dependency_outputs,
                        "project_summary": self.project_summary,
                        "expected_output": expected_output,
                        "step": step_num,
                        "action": action,
                        "targets": targets,
                        "description": description,
                    }
                    print(f"[Orchestrator] Step {step_num}: {action} on {targets} using {agent_name} - {description}")
                    agent = self.agent_registry.get(agent_name)
                    if not agent:
                        print(f"[Orchestrator] Agent {agent_name} not implemented. Skipping step.")
                        completed_steps.add(step_num)
                        steps_to_run.remove(step_num)
                        continue
                    output = self._handle_agent_step(agent_name, agent, step, context)
                    step_outputs[step_num] = output
                    completed_steps.add(step_num)
                    steps_to_run.remove(step_num)
                    progress = True
            if not progress:
                print("[Orchestrator] Could not make progress on plan execution due to unsatisfied dependencies. Possible cycle or missing step.")
                break
        root_dir_name = self._extract_root_dir(file_list)
        if not root_dir_name:
            root_dir_name = f"project_{int(time.time())}"
        output_path = os.path.join("projects", root_dir_name)
        os.makedirs(output_path, exist_ok=True)
        self.file_agent.project_state.commit_to_disk(output_path)
        print(f"\n[Orchestrator] Project saved to: {output_path}\n")

    def _handle_agent_step(self, agent_name, agent, step, context):
        # Handler map for agent execution
        if agent_name == "DeveloperAgent":
            project_view = self.file_agent.project_state.get_project_view()
            file_changes = agent.act(project_view, step["description"], context)
            for change in file_changes:
                file_path = change.get("file")
                content = change.get("content")
                desc = change.get("description")
                if not file_path or file_path.endswith('/') or file_path.strip() == '':
                    continue
                self.file_agent.project_state.write_file(file_path, content)
                print(f"[Orchestrator] Updated {file_path}: {desc}")
            summary_input = f"Files updated: {[c.get('file') for c in file_changes]}\nDescriptions: {[c.get('description') for c in file_changes]}"
            self.project_summary = self.summary_agent.act(self.project_summary, summary_input)
            return {"file_changes": file_changes, "summary": self.project_summary}
        elif agent_name in ("CommandRunnerAgent", "GrepSearchAgent", "GitAgent"):
            # Generate the command
            if agent_name == "GrepSearchAgent":
                pattern = step["description"] or step["action"]
                search_path = step["targets"][0] if step["targets"] else "."
                cmd_result = agent.act(pattern, search_path, context)
            elif agent_name == "GitAgent":
                cmd_result = agent.act(step["description"], context)
            else:
                cmd_result = agent.act(step["description"], context)
            command = cmd_result["command"]
            shell_type = cmd_result["shell"]
            print(f"[Orchestrator] Generated command: {command} (shell: {shell_type})")
            # Execute the command
            exec_result = execute_command(command, shell_type)
            print(f"[Orchestrator] Command output: {exec_result['output']}")
            if exec_result["error"]:
                print(f"[Orchestrator] Command error: {exec_result['error']}")
            return {"command": command, "shell": shell_type, "exec_result": exec_result}
        else:
            # Default: just call act with description and context
            result = agent.act(step["description"], context)
            print(f"[Orchestrator] Agent {agent_name} output: {result}")
            return result

    def _extract_root_dir(self, file_list):
        for path in file_list:
            parts = path.split('/')
            if len(parts) > 1:
                return parts[0]
        return None 